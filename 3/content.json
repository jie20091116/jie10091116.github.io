{"meta":{"title":"刻猫猫的笔记本","subtitle":"目标是星辰与大海","description":"用来记录每天的学习内容","author":"AliciaChi","url":"http://engravesunny.github.io","root":"/"},"pages":[{"title":"追番","date":"2022-10-09T09:27:16.573Z","updated":"2022-10-09T09:27:16.573Z","comments":true,"path":"bangumis/index.html","permalink":"http://engravesunny.github.io/bangumis/index.html","excerpt":"","text":""},{"title":"about","date":"2022-10-08T12:00:36.000Z","updated":"2022-10-08T15:14:03.377Z","comments":true,"path":"about/index.html","permalink":"http://engravesunny.github.io/about/index.html","excerpt":"","text":"在source&#x2F;about下写简历"},{"title":"friends","date":"2022-10-08T12:01:56.000Z","updated":"2022-10-08T12:02:09.027Z","comments":true,"path":"friends/index.html","permalink":"http://engravesunny.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-10-08T11:59:55.000Z","updated":"2022-10-09T08:29:57.952Z","comments":true,"path":"categories/index.html","permalink":"http://engravesunny.github.io/categories/index.html","excerpt":"","text":"这里是分类哦"},{"title":"tags","date":"2022-10-08T11:58:37.000Z","updated":"2022-10-08T11:59:13.217Z","comments":true,"path":"tags/index.html","permalink":"http://engravesunny.github.io/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-10-08T12:01:13.000Z","updated":"2022-10-08T12:01:30.031Z","comments":true,"path":"contact/index.html","permalink":"http://engravesunny.github.io/contact/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-10-08T15:30:51.679Z","updated":"2022-10-08T15:30:51.679Z","comments":true,"path":"galleries/index.html","permalink":"http://engravesunny.github.io/galleries/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-10-10T14:23:26.167Z","updated":"2022-10-10T14:23:26.167Z","comments":true,"path":"galleries/动漫风景/index.html","permalink":"http://engravesunny.github.io/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"涩图","date":"2022-10-09T08:55:57.090Z","updated":"2022-10-09T08:55:57.090Z","comments":true,"path":"galleries/涩图/index.html","permalink":"http://engravesunny.github.io/galleries/%E6%B6%A9%E5%9B%BE/index.html","excerpt":"","text":""},{"title":"美图","date":"2022-10-09T08:54:45.910Z","updated":"2022-10-08T15:37:56.994Z","comments":true,"path":"galleries/美图/index.html","permalink":"http://engravesunny.github.io/galleries/%E7%BE%8E%E5%9B%BE/index.html","excerpt":"","text":""}],"posts":[{"title":"关于后端返回的大数字问题","slug":"关于后端返回大数字的问题","date":"2022-10-30T02:29:22.000Z","updated":"2022-10-29T03:01:59.476Z","comments":true,"path":"2022/10/30/guan-yu-hou-duan-fan-hui-da-shu-zi-de-wen-ti/","link":"","permalink":"http://engravesunny.github.io/2022/10/30/guan-yu-hou-duan-fan-hui-da-shu-zi-de-wen-ti/","excerpt":"","text":"关于后端返回的大数字问题我们在请求文章详情的接口时会返回404，是因为我们请求发送的文章id不正确 javaScript可以准确地表示2^-53到2^53之间的整数（不包含端点），超过这个范围就无法精确的表示这个值，因此使得javaScript不适合进行科学和金融方面的精确计算 Math.pow(2, 53) // 9007199254740992 9007199254740992 // 9007199254740992 9007199254740993 // 9007199254740992 Math.pow(2, 53) === Math.pow(2, 53) + 1 // true ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true Number.MAX_SAFE_INTEGER === 9007199254740991 // true Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true Number.MIN_SAFE_INTEGER === -9007199254740991 // true 上面代码可以看出javaScript可以精确表示的整数的极限 后端返回的数据一般都是JSON格式的字符串 '&amp;#123; \"id\": 9007199254740995, \"name\": \"Jack\", \"age\": 18 &amp;#125;' 如果这个字符不做任何处理，你能方便的获取到字符串中的指定数据吗？非常麻烦。所以我们要把它转换为 JavaScript 对象来使用就很方便了。 幸运的是 axios 为了方便我们使用数据，它会在内部使用 JSON.parse() 把后端返回的数据转为 JavaScript 对象。 // &amp;#123; id: 9007199254740996, name: 'Jack', age: 18 &amp;#125; JSON.parse('&amp;#123; \"id\": 9007199254740995, \"name\": \"Jack\", \"age\": 18 &amp;#125;') 可以看到，超出安全整数范围的 id 无法精确表示，这个问题并不是 axios 的错。 了解了什么是大整数的概念，接下来的问题是如何解决？ json-bigint 是一个第三方包，它可以帮我们很好的处理这个问题。 使用它的第一步就是把它安装到你的项目中。 npm i json-bigint 下面是使用它的一个简单示例。 const jsonStr = '&amp;#123; \"art_id\": 1245953273786007552&amp;#125;' console.log(JSON.parse(jsonStr)) // 1245953273786007600 // JSON.stringify() // JSONBig 可以处数据中超过 JavaScript 安全整数范围的问题 console.log(JSONBig.parse(jsonStr)) // 把 JSON 格式的字符串转为 JavaScript 对象 // 使用的时候需要把 BigNumber 类型的数据转为字符串来使用 console.log(JSONBig.parse(jsonStr).art_id.toString()) // 1245953273786007552 console.log(JSON.stringify(JSONBig.parse(jsonStr))) console.log(JSONBig.stringify(JSONBig.parse(jsonStr))) // 把 JavaScript 对象 转为 JSON 格式的字符串转 json-bigint 会把超出 JS 安全整数范围的数字转为一个 BigNumber 类型的对象，对象数据是它内部的一个算法处理之后的，我们要做的就是在使用的时候转为字符串来使用。 通过 Axios 请求得到的数据都是 Axios 处理（JSON.parse）之后的，我们应该在 Axios 执行处理之前手动使用 json-bigint 来解析处理。Axios 提供了自定义处理原始后端返回数据的 API：transformResponse 。 import axios from 'axios' import jsonBig from 'json-bigint' var json = '&amp;#123; \"value\" : 9223372036854775807, \"v2\": 123 &amp;#125;' console.log(jsonBig.parse(json)) const request = axios.create(&amp;#123; baseURL: 'http://ttapi.research.itcast.cn/', // 接口基础路径 // transformResponse 允许自定义原始的响应数据（字符串） transformResponse: [function (data) &amp;#123; try &amp;#123; // 如果转换成功则返回转换的数据结果 return jsonBig.parse(data) &amp;#125; catch (err) &amp;#123; // 如果转换失败，则包装为统一数据格式并返回 return &amp;#123; data &amp;#125; &amp;#125; &amp;#125;] &amp;#125;) export default request 扩展：ES2020 BigIntES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。参考链接： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&#x2F;BigInt http://es6.ruanyifeng.com/#docs/number#BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B","categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"后端的大数字","slug":"后端的大数字","permalink":"http://engravesunny.github.io/tags/%E5%90%8E%E7%AB%AF%E7%9A%84%E5%A4%A7%E6%95%B0%E5%AD%97/"}]},{"title":"搜索细节问题","slug":"关于搜索时的一些细节","date":"2022-10-28T03:20:30.000Z","updated":"2022-10-28T02:57:30.653Z","comments":true,"path":"2022/10/28/guan-yu-sou-suo-shi-de-yi-xie-xi-jie/","link":"","permalink":"http://engravesunny.github.io/2022/10/28/guan-yu-sou-suo-shi-de-yi-xie-xi-jie/","excerpt":"","text":"防抖优化防抖：防止用户在输入关键词是input的change事件不断触发，导致过多不必要的请求 解决方案：1、加定时器 2、使用插件 我们这里使用lodash插件 1、安装lodash # yarn add lodash npm i lodash 2、防抖处理 // lodash 支持按需加载，有利于打包结果优化 import &amp;#123; debounce &amp;#125; from 'lodash' 不建议下面这样实用，因为这样会加载整个模块 import _ from 'lodash' _.debounce() // debounce函数 // 参数1：函数 // 参数2：防抖时间 // 返回值：防抖之后的函数，和参数1功能是一样的 onSearchInput:debounce(async ()=>&amp;#123; const searchContent = this.searchContent if(!searchContent) &amp;#123; return &amp;#125; // 1. 请求获取数据 const &amp;#123; data &amp;#125; = await getSuggestions(searchContent) // 2. 将数据添加到组件实例中 this.suggestions = data.data.options // 3. 模板绑定 &amp;#125;, 200) 搜索关键字高亮如何将字符串中的指定字符在网页中高亮展示？将需要高亮的字符包裹 HTML 标签，为其单独设置颜色。 \"Hello &lt;span style=\"color: red\">World&lt;/span>\" 在 Vue 中如何渲染带有 HTML 标签的字符串？ data () &amp;#123; return &amp;#123; htmlStr: 'Hello &lt;span style=\"color: red\">World&lt;/span>' &amp;#125; &amp;#125; &lt;div>&amp;#123;&amp;#123; htmlStr &amp;#125;&amp;#125;&lt;/div> &lt;div v-html=\"htmlStr\">&lt;/div> 如何把字符串中指定字符统一替换为高亮（包裹了 HTML）的字符？ const str = \"Hello World\" // 结果：&lt;span style=\"color: red\">Hello&lt;/span> World \"Hello World\".replace('Hello','&lt;span style=\"color: red\">Hello&lt;/span>') //如果想全文替换，使用正则表达式 // g 全局 // i 忽略大小写 // &lt;span style=\"color: red\">Hello&lt;/span> World &lt;span style=\"color: red\">Hello&lt;/span> abc \"Hello World Hello abc\".replace(/Hello/gi, '&lt;span style=\"color: red\">Hello&lt;/span>') 一个小扩展：使用字符串的 split 结合数组的 join 方法实现高亮 var str = \"hello world 你好 hello\"; // [\"\", \" world 你好 \", \"\"] const arr = str.split(\"hello\"); // \"&lt;span>hello&lt;/span> world 你好 &lt;span>hello&lt;/span>\" arr.join(\"&lt;span>hello&lt;/span>\"); 下面是具体的处理。 1、在method中添加一个方法处理高亮 // 参数 source：原始字符串 // 参数 keyword: 需要高亮的关键字 // 返回值：替换之后的高亮字符串 highlight (source, keyword) &amp;#123; // /searchContent/ 正则表达式中的一切内容都会当做字符串使用 // 这里可以 new RegExp 方式根据字符串创建一个正则表达式 // RegExp 是原生 JavaScript 的内置构造函数 // 参数1：字符串，注意，这里不要加 // // 参数2：匹配模式，g 全局，i 忽略大小写 const reg = new RegExp(keyword, 'gi') return source.replace(reg, `&lt;span style=\"color: #3296fa\">$&amp;#123;keyword&amp;#125;&lt;/span>`) &amp;#125;, 2、然后在联想建议列表项中绑定调用 &lt;!-- 联想建议 --> &lt;van-cell-group v-else-if=\"searchContent\"> &lt;van-cell icon=\"search\" v-for=\"(item, index) in suggestions\" :key=\"index\" @click=\"onSearch(item)\" > &lt;div slot=\"title\" v-html=\"highlight(item, searchContent)\">&lt;/div> &lt;/van-cell> &lt;/van-cell-group> &lt;!-- /联想建议 --> 数据持久化1、利用 watch 监视统一存储数据 watch: &amp;#123; searchHistories (val) &amp;#123; // 同步到本地存储 setItem('serach-histories', val) &amp;#125; &amp;#125;, 2、初始化的时候从本地存储获取数据 data () &amp;#123; return &amp;#123; ... searchHistories: getItem('serach-histories') || [], &amp;#125; &amp;#125;","categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"search","slug":"search","permalink":"http://engravesunny.github.io/tags/search/"}]},{"title":"处理相对时间","slug":"处理相对时间","date":"2022-10-28T02:37:10.000Z","updated":"2022-10-28T02:30:32.166Z","comments":true,"path":"2022/10/28/chu-li-xiang-dui-shi-jian/","link":"","permalink":"http://engravesunny.github.io/2022/10/28/chu-li-xiang-dui-shi-jian/","excerpt":"","text":"处理相对时间推荐两个第三方库： Moment.js Day.js 两者都是专门用于处理时间的 JavaScript 库，功能差不多，因为 Day.js 的设计就是参考的 Moment.js。但是 Day.js 相比 Moment.js 的包体积要更小一些，因为它采用了插件化的处理方式。 Day.js 是一个轻量的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持完全一样，如果您曾经用过 Moment.js, 那么您已经知道如何使用 Day.js 。 Day.js可以运行在浏览器和Node.js中。 🕒和Moment.js相同的API和用法 💪 不可变数据(Immutable) 🔥支持链式操作(Chainable) 🌐国际化 📦 仅仅2kb大小的微库 👫全浏览器兼容 1、安装 npm i dayjs 2、创建 utils/dayjs.js import Vue from 'vue' import daujs from 'dayjs' // 加载中文语言包 import 'dayjs/local/zh-cn' import relativeTime from 'dayjs/plugin/relativeTime' // 配置使用处理相对时间的插件 dayjs.extend(relativeTime) // 配置使用中文语言包 dayjs.local('zh-cn') // 全局注册过滤器 Vue:filter('relativeTime', value => &amp;#123; return dayjs().to(dayjs(value)) &amp;#125;) 3、在main.js中加载初始化 import './utils/dayjs' 4、使用过滤器 &lt;p>&amp;#123;&amp;#123; 日期数据 | relativeTime &amp;#125;&amp;#125;&lt;/p>","categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"day.js","slug":"day-js","permalink":"http://engravesunny.github.io/tags/day-js/"}]},{"title":"关于第三方图片403的问题","slug":"关于第三方图片资源403的问题","date":"2022-10-28T02:05:11.000Z","updated":"2022-10-28T02:18:29.507Z","comments":true,"path":"2022/10/28/guan-yu-di-san-fang-tu-pian-zi-yuan-403-de-wen-ti/","link":"","permalink":"http://engravesunny.github.io/2022/10/28/guan-yu-di-san-fang-tu-pian-zi-yuan-403-de-wen-ti/","excerpt":"","text":"关于第三方图片资源403问题为什么文章列表数据中的好多图片资源请求失败返回 403？ 这是因为我们项目的接口数据是后端通过爬虫抓取的第三方平台内容，而第三方平台对图片资源做了防盗链处理 第三方平台怎么处理图片的资源保护的？ 服务端一般使用Referer 请求头识别访问来源，然后处理资源访问 Referer 是什么东西？ 扩展参考:http://www.ruanyifeng.com/blog/2019/06/http-referer.html Referer 是 HTTP 请求头的一部分，当浏览器向 Web 服务器发送请求的时候，一般会带上 Referer，它包含了当前请求资源的来源页面的地址。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。 需要注意的是referer实际上是’referrer’误拼写。参见HTTP referer on Wikipedia （HTTP referer 在维基百科上的条目）来获取更详细的信息。 怎么解决？ 不要发送Referrer，对方服务端就不知道笔从哪里来了，姑且认为是自己人 如何设置不发送referrer？ 用 &lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt; 或者 &lt;link&gt; 元素上的 referrerpolicy 属性为其设置独立的请求策略，例如： &lt;img src=\"http://……\" referrerPolicy=\"no-referrer\"> 或者直接在 HTMl 页面头中通过 meta 属性全局配置： &lt;meta name=\"referrer\" content=\"no-referrer\" />","categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"第三方图片","slug":"第三方图片","permalink":"http://engravesunny.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%9B%BE%E7%89%87/"}]},{"title":"优化设置Token","slug":"优化设置Token","date":"2022-10-27T02:49:33.000Z","updated":"2022-10-27T02:55:14.728Z","comments":true,"path":"2022/10/27/you-hua-she-zhi-token/","link":"","permalink":"http://engravesunny.github.io/2022/10/27/you-hua-she-zhi-token/","excerpt":"","text":"优化设置Token项目中的接口大部分需要我们提供token才有访问权限通过接口文档我们可以看到，后端接口要求我们将token放到请求头header中并以下面的格式发送 字段名称: Authorization字段值: Bearer token 方式一: 在每次请求的时候手动添加(麻烦)。 axios(&amp;#123; method: '', url: '', header: &amp;#123; Authorization: 'Bearer token' &amp;#125; &amp;#125;) 方式二：使用请求拦截器统一添加(推荐，更方便) 在 src/utils/request.js 中添加拦截器统一设置 token： /** * 请求模块 */ import axios from 'axios' import store from '@/store' const request = axios.create(&amp;#123; baseURL: 'http://toutiao.itheima.net' // 接口的基准地址 &amp;#125;) // 请求拦截器 request.interceptors.request.use(config => &amp;#123; // config: 本次请求的配置对象 // config 里面有一个属性：header const &amp;#123; user &amp;#125; = store.state if(user &amp;&amp; user.token) &amp;#123; config.header.Authorization = `Bearer $&amp;#123;user.token&amp;#125;` &amp;#125; return config &amp;#125;, error => &amp;#123; return Promise.reject(error) &amp;#125;) //响应拦截器 export default request","categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"token","slug":"token","permalink":"http://engravesunny.github.io/tags/token/"}]},{"title":"关于.postcssrc.js配置文件","slug":"关于.postcssrc.js配置文件","date":"2022-10-27T01:52:23.000Z","updated":"2022-10-27T02:32:14.191Z","comments":true,"path":"2022/10/27/guan-yu.postcssrc.js-pei-zhi-wen-jian/","link":"","permalink":"http://engravesunny.github.io/2022/10/27/guan-yu.postcssrc.js-pei-zhi-wen-jian/","excerpt":"","text":"关于.postcssrc.js配置文件module.exports = &amp;#123; plugin: &amp;#123; 'autoprefixer': &amp;#123; browsers: ['Android >= 4.0', 'iOS >= 8'] &amp;#125;, 'postcss-pxtorem': &amp;#123; rootValue: 37.5, propList: ['*'] &amp;#125; &amp;#125; &amp;#125; .postcssrc.js是 PostCSS 的配置文件。 （1）PostCSS 介绍 PostCSS 是一个处理 CSS 的处理工具，本身功能比较单一，它主要负责解析 CSS 代码，再交由插件来进行处理，它的插件体系非常强大，所能进行的操作是多种多样的，例如： Autoprefixer 插件可以实现自动添加浏览器相关的声明前缀 PostCSS Preset Env 插件可以让你使用更新的CSS语法特性并实现向下兼容 postcss-pxtorem 可以实现将 px 转换为 rem … 目前 PostCSS 已经有 200 多个功能各异的插件。开发人员也可以根据项目的需要，开发出自己的 PostCSS 插件。 PostCSS 一般不单独使用，而是与已有的构建工具进行集成。 Vue CLI 默认集成了 PostCSS，并且默认开启了 autoprefixer 插件。 Vue CLI内部使用了PostCSS。你可以通过.postcssrc或任何 postcss-load-config支持的配置资源来配置PostCSS也可以通过vue.config.js中的css.loaderOptions.postcss配置 postcss-loader。我们默认开启了autoprefixer。如果要配置目标浏览器，可使用 package.json 的 browserslist 字段。 （2）Autoprefixer 插件的配置 autoprefixer是一个自动添加浏览器前缀的 PostCss 插件，browsers 用来配置兼容的浏览器版本信息，但是写在这里的话会引起编译器警告。 Replace Autoprefixer browsers option to Browserslist config. Use browserslist key in package.json or .browserslistrc file. Using browsers option can cause errors. Browserslist config can be used for Babel, Autoprefixer, postcss-normalize and other tools. If you really need to use option, rename it to overrideBrowserslist. Learn more at: https://github.com/browserslist/browserslist#readme https://twitter.com/browserslist 警告意思就是说你应该将 browsers 选项写到 package.json 或 .browserlistrc 文件中。 [Android] >= 4.0 [iOS] >= 8 具体语法请参考这里。（3）postcss-pxtorem 插件的配置 rootValue: 表示根元素字体大小，它会根据元素大小进行单位转换 propList: 用来设定可以从px转为rem的属性 例如*就是所有的属性都要转换，width就是仅仅转换width属性 rootValue 应该如何设置呢？ 如果你使用的是基于 lib-flexable 的 REM 适配方案，则应该设置为你的设计稿的十分之一。 例如设计稿是 750 宽，则应该设置为 75。 大多数设计稿的原型都是以 iphone6 为原型，iphone6 设备的宽是 750，我们的设计稿也是这样。 但是 Vant 建议设置为 37.5，为什么呢？ 因为 Vant 是基于 375 写的，所以如果你设置为 75 的话，Vant 的样式就小了一半。 所以如果设置为37.5的话，Vant 的样式是没有问题的，但是我们在测量设计稿的时候都必须除2才能使用，否则就会变得很大。 这样做其实也没有问题，但是有没有更好的办法呢？我就想实现测量多少写多少（不用换算）。于是聪明的你就想，可以不可以这样来做？ 如果是 Vant 的样式，就把 rootValue 设置为 37.5 来转换 如果是我们的样式，就按照 75 的 rootValue 来转换 通过查阅文档我们可以看到 rootValue 支持两种参数类型： 数字：固定值 函数：动态计算返回 postcss-pxtorem处理每个 CSS 文件的时候都会来调用这个函数 它会把被处理的 CSS 文件相关的信息通过参数传递给该函数 所以我们修改配置如下: /** * PostCSS配置文件 */ module.exports - &amp;#123; // 配置要是用的PostCSS插件 plugins: &amp;#123; // 配置使用 postcss-pxtorem 插件 // 作用：把px 转为 rem 'postcss-pxtorem': &amp;#123; rootValue (&amp;#123; file &amp;#125;) &amp;#123; return file.indexOf('vant') !== -1 ? 37.5 : 75 &amp;#125;, propList: ['*'] &amp;#125; &amp;#125; &amp;#125; 配置完毕，把服务重启一下，最后测试，very good。","categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"postcssrc插件","slug":"postcssrc插件","permalink":"http://engravesunny.github.io/tags/postcssrc%E6%8F%92%E4%BB%B6/"}]},{"title":"关于用户token的处理","slug":"关于用户token的处理","date":"2022-10-26T02:02:33.000Z","updated":"2022-10-27T02:27:16.965Z","comments":true,"path":"2022/10/26/guan-yu-yong-hu-token-de-chu-li/","link":"","permalink":"http://engravesunny.github.io/2022/10/26/guan-yu-yong-hu-token-de-chu-li/","excerpt":"","text":"处理用户 TokenToken是用户登录成功后服务端返回的一个身份令牌，在项目中的多个业务中需要使用到: 访问需要授权的API 校验页面的访问权限 … 但是我们只有在第一次用户登录成功之后才能拿到Token。所以为了能在其它模块中获取到Token数据，我们需要把它存储到一个公共的位置，方便随时取用。往哪儿存？ 本地储存 获取麻烦 数据不是响应式 Vuex容器（推荐） 获取方便 响应式的 使用容器存储Token的思路： 登录成功后，将Token存储到Vuex容器中 获取方便 响应式 为了持久化，还需要把Token存到本地储存 持久化 下面是具体实现 1、在src/store/index.js中 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store(&amp;#123; state:&amp;#123; // 用户登录的状态信息 user: JSON.parse(window.localStorage.getItem(\"TOUTIAO_USER\")) // user: null &amp;#125;, mutations: &amp;#123; setUser (state, user) &amp;#123; state.user = user window.localStorage.setItem('TOUTIAO_USER',JSON.stringify(user)) &amp;#125; &amp;#125;, action: &amp;#123; &amp;#125;, modules: &amp;#123; &amp;#125; &amp;#125;) 2、登录成功以后将后端返回的 token 相关数据存储到容器中 async onLogin () &amp;#123; this.$toast.loading(&amp;#123; duration: 0, // 持续时间，0表示持续展示不停止 forbidClick: true, // 是否禁止背景点击 message: '登录中...' // 提示消息 &amp;#125;) try&amp;#123; const res = await login(this.user) this.$store.commit('setUser',res.data.data) this.$toast.success('登陆成功') &amp;#125; catch (err) &amp;#123; console.log('登录失败', err) this.$toast.fail('登录失败，手机号或验证码错误') &amp;#125; // 停止 loading，它会把当前页面中所有的 toast 都给清除 // loginToast.clear() &amp;#125; 优化封装本地存储操作模块创建src/utils/storage.js模块。 export const getItem = name => &amp;#123; const data = window.localStorage.getItem(name) try&amp;#123; return JSON.parse(data) &amp;#125; catch (err) &amp;#123; return data &amp;#125; &amp;#125; export const setItem = (name, value) => &amp;#123; if(typeof value === 'object') &amp;#123; value = JSON.stringify(value) &amp;#125; window.localStorage.setItem('name',value) &amp;#125; export const removeItem = name => &amp;#123; window.localStorage.removeItem(name) &amp;#125; 关于 Token 过期问题登录成功之后后端会返回两个 Token： token：访问令牌，有效期2小时 refresh_token：刷新令牌，有效期14天，用于访问令牌过期之后重新获取新的访问令牌 我们的项目接口中设定的 Token 有效期是 2 小时，超过有效期服务端会返回 401 表示 Token 无效或过期了。 为什么过期时间这么短？ 为了安全，例如 Token 被别人盗用 过期了怎么办？ 让用户重新登录，用户体验太差了 使用refresh-token解决token过期 如何使用 refresh_token 解决 token 过期？ 到课程的后面我们开发的业务功能丰富起来之后，再给大家讲解 Token 过期处理。 大家需要注意的是在学习测试的时候如果收到 401 响应码，请重新登录再测试。 概述：服务器生成token的过程中，会有两个时间，一个是token失效时间，一个是token刷新时间，刷新时间肯定比失效时间长，当用户的 token 过期时，你可以拿着过期的token去换取新的token，来保持用户的登陆状态，当然你这个过期token的过期时间必须在刷新时间之内，如果超出了刷新时间，那么返回的依旧是 401。 处理流程: 在axios的拦截器中加入token刷新逻辑 当用户token过期时，去向服务器请求新的 token 把旧的token替换为新的token 然后继续用户当前的请求 在请求的响应拦截器中统一处理 token 过期： /** * 封装 axios 请求模块 */ import axios from \"axios\"; import jsonBig from \"json-bigint\"; import store from \"@/store\"; import router from \"@/router\"; // axios.create 方法：复制一个 axios const request = axios.create(&amp;#123; baseURL: \"http://ttapi.research.itcast.cn/\" // 基础路径 &amp;#125;); /** * 配置处理后端返回数据中超出 js 安全整数范围问题 */ request.defaults.transformResponse = [ function(data) &amp;#123; try &amp;#123; return jsonBig.parse(data); &amp;#125; catch (err) &amp;#123; return &amp;#123;&amp;#125;; &amp;#125; &amp;#125; ]; // 请求拦截器 request.interceptors.request.use( function(config) &amp;#123; const user = store.state.user; if (user) &amp;#123; config.headers.Authorization = `Bearer $&amp;#123;user.token&amp;#125;`; &amp;#125; // Do something before request is sent return config; &amp;#125;, function(error) &amp;#123; // Do something with request error return Promise.reject(error); &amp;#125; ); // 响应拦截器 request.interceptors.response.use( // 响应成功进入第1个函数 // 该函数的参数是响应对象 function(response) &amp;#123; // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data return response; &amp;#125;, // 响应失败进入第2个函数，该函数的参数是错误对象 async function(error) &amp;#123; // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error // 如果响应码是 401 ，则请求获取新的 token // 响应拦截器中的 error 就是那个响应的错误对象 console.dir(error); if (error.response &amp;&amp; error.response.status === 401) &amp;#123; // 校验是否有 refresh_token const user = store.state.user; if (!user || !user.refresh_token) &amp;#123; router.push(\"/login\"); // 代码不要往后执行了 return; &amp;#125; // 如果有refresh_token，则请求获取新的 token try &amp;#123; const res = await axios(&amp;#123; method: \"PUT\", url: \"http://ttapi.research.itcast.cn/app/v1_0/authorizations\", headers: &amp;#123; Authorization: `Bearer $&amp;#123;user.refresh_token&amp;#125;` &amp;#125; &amp;#125;); // 如果获取成功，则把新的 token 更新到容器中 console.log(\"刷新 token 成功\", res); store.commit(\"setUser\", &amp;#123; token: res.data.data.token, // 最新获取的可用 token refresh_token: user.refresh_token // 还是原来的 refresh_token &amp;#125;); // 把之前失败的用户请求继续发出去 // config 是一个对象，其中包含本次失败请求相关的那些配置信息，例如 url、method 都有 // return 把 request 的请求结果继续返回给发请求的具体位置 return request(error.config); &amp;#125; catch (err) &amp;#123; // 如果获取失败，直接跳转 登录页 console.log(\"请求刷线 token 失败\", err); router.push(\"/login\"); &amp;#125; &amp;#125; return Promise.reject(error); &amp;#125; ); export default request;","categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"token","slug":"token","permalink":"http://engravesunny.github.io/tags/token/"}]},{"title":"网易云音乐案例","slug":"10.11-10.12又写了一遍网易云音乐案例","date":"2022-10-12T13:23:53.000Z","updated":"2022-10-12T15:08:32.821Z","comments":true,"path":"2022/10/12/10.11-10.12-you-xie-liao-yi-bian-wang-yi-yun-yin-le-an-li/","link":"","permalink":"http://engravesunny.github.io/2022/10/12/10.11-10.12-you-xie-liao-yi-bian-wang-yi-yun-yin-le-an-li/","excerpt":"","text":"网易云案例总结(临近考试该复习了停更一段时间(T⌓T))1.又熟悉一遍vant组件库的使用1.局部引入配置 module.exports = &amp;#123; presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ [\"import\", &amp;#123; \"libraryName\": \"vant\", \"libraryDirectory\": \"es\", \"style\": true &amp;#125;,'vant'] ] &amp;#125; 通过此配置可以实现vant组件库的局部引入即import &#123;&#125; from &#39;vant&#39; 2.更加熟悉封装axios请求的操作1.先在src下新建utils&#x2F;request.js,对网络请求进行二次封装 // 网络请求 - 二次封装 import axios from \"axios\"; axios.defaults.baseURL = 'http://localhost:3000' export default axios 2.再在src下新建api文件，其中新建index.js作为请求总汇,分别新建Home.js,Play.js,Search.js进行具体请求操作 // Home.js // 文件名-尽量和模块页面文件名统一 import request from '@/utils/request' //首页-推荐歌单 export const recommendMusic = params => request(&amp;#123; url:'/personalized', params //将来可能传入params的值&amp;#123;limit:20&amp;#125; &amp;#125;) // 首页-最新音乐 export const newMusic = params => request(&amp;#123; url:'/personalized/newsong', params &amp;#125;) // Search.js // 搜索模块 import request from '@/utils/request' export const hotSearch = params => request(&amp;#123; url:'/search/hot', params &amp;#125;) export const searchResultList = params => request(&amp;#123; url:'/cloudsearch', params &amp;#125;) // Play.js import request from '../utils/request' // 播放页 - 获取歌曲详情 export const getSongById = (id) => request(&amp;#123; url: `/song/detail?ids=$&amp;#123;id&amp;#125;`, method: \"GET\" &amp;#125;) // 播放页 - 获取歌词 export const getLyricById = (id) => request(&amp;#123; url: `/lyric?id=$&amp;#123;id&amp;#125;`, method: \"GET\" &amp;#125;) // index.js作为请求总汇 // api文件夹下 各个请求模块js，同一来到index.js再向外导出 import &amp;#123;recommendMusic,newMusic&amp;#125; from './Home' import &amp;#123; hotSearch,searchResultList &amp;#125; from './Search' import &amp;#123;getSongById,getLyricById&amp;#125; from './Play' export const recommendMusicAPI = recommendMusic //请求推荐歌单的方法导出 export const newMusicAPI = newMusic //请求最新音乐的方法导出 export const hotSearchAPI = hotSearch //搜索-热搜关键词 export const searchResultListAPI = searchResultList //搜索-搜索结果 export const getSongByIdAPI = getSongById //搜索-搜索结果 export const getLyricByIdAPI = getLyricById //搜索-搜索结果 作用：这样做更利于不同请求的调用和更改，更便于维护 3.更加熟悉vue中路由的操作src下新建router&#x2F;index.js import Vue from 'vue' import VueRouter from 'vue-router' import Layout from '@/view/Layout' import Home from '@/view/Home' import Search from '@/view/Search' import Play from '@/view/Play' Vue.use(VueRouter) const routes = [ &amp;#123; path:'/', redirect:'/layout' &amp;#125;, &amp;#123; path:'/layout', component:Layout, children:[ &amp;#123; path:'home', component:Home, meta:&amp;#123; //meta保存路由对象额外信息 title:'首页' &amp;#125; &amp;#125;, &amp;#123; path:'search', component:Search, meta:&amp;#123; title:'搜索' &amp;#125; &amp;#125; ] &amp;#125;, &amp;#123; path:'/play', component:Play &amp;#125; ] export default new VueRouter(&amp;#123; routes &amp;#125;) 对路由跳转传参，重定向，子路由更加深入的了解 入口文件导入 // main.js import Vue from 'vue' import App from './App.vue' import '@/mobile/flexible' import '@/styles/reset.css' import router from '@/router' // 测试封装api的方法 import &amp;#123; recommendMusicAPI &amp;#125; from './api' async function fn()&amp;#123; const res = await recommendMusicAPI() console.log(res); &amp;#125; fn() import &amp;#123; Tabbar, TabbarItem ,NavBar,Col, Row,Image as VanImage,Cell, CellGroup,Icon,Search,List,&amp;#125; from 'vant'; Vue.use(List); Vue.use(Search); Vue.use(Cell); Vue.use(Icon); Vue.use(CellGroup); Vue.use(VanImage); Vue.use(Col); Vue.use(Row); Vue.use(Tabbar); Vue.use(TabbarItem); Vue.use(NavBar); Vue.config.productionTip = false new Vue(&amp;#123; router, render: h => h(App), &amp;#125;).$mount('#app')","categories":[{"name":"Vue","slug":"Vue","permalink":"http://engravesunny.github.io/categories/Vue/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Vue","slug":"Vue","permalink":"http://engravesunny.github.io/tags/Vue/"}]},{"title":"redux学习笔记","slug":"10.10redux笔记","date":"2022-10-10T13:23:53.000Z","updated":"2022-10-10T14:08:34.383Z","comments":true,"path":"2022/10/10/10.10redux-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/10/10.10redux-bi-ji/","excerpt":"","text":"Redux概述Redux为何物 Redux是用于做状态管理的JS库 可用于React，Angular，Vue等项目中，常用于React 集中式管理React应用多个组件共享的状态 何时用Redux 某个组件的状态需要让其他组件拿到 一个组件要改变另一个组件的状态 使用原则：不到万不得已不要轻易使用 Redux 工作流程 组件想用Redux中的状态：把动作类型和数据告诉Action Creators Action Creators创建actions:同步action是一个普通对象，异步action是一个函数 Store调用dispatch()分发给Reducers执行 Reducers接收previousState,action两个参数，对状态进行加工后返回新状态 Store调用getState()把状态传给组件 核心概念action: 表示动作的对象，包含两个属性 type:表示属性，值为字符串，唯一，必须属性 data:数据属性，类型任意，可选属性 {type:’string’,data:data} reducer: 用于初始化状态、加工状态 根据旧状态和action产生新状态 是纯函数 纯函数：输入同样的实参，必定得到同样的输出 不能改写参数数据 不产生副作用，如网络请求、输入输出设备（网络请求不稳定） 不能调用 Date.now() 、Math.random() 等不纯方法 store: Redux核心对象，内部维护着state和reducer 核心API store.getState():获取状态 store.dispatch(action):分发任务，触发reducer调用，产生新状态 store.subscribe(func):注册监听函数，当状态改变自动调用 一个求和案例// App.jsx import React, &amp;#123; Component &amp;#125; from 'react' import Count from './components/Count' export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;Count /> &lt;/div> ) &amp;#125; &amp;#125; // index.js import React from 'react' import ReactDOM from 'react-dom' import App from './App' import store from './redux/store' ReactDOM.render(&lt;App />, document.getElementById('root')) // 状态改变重新渲染 App 组件 store.subscribe(() => &amp;#123; ReactDOM.render(&lt;App />, document.getElementById('root')) &amp;#125;) // redux/constant.js // 保存常量值 export const INCREMENT = 'increment' export const DECREMENT = 'decrement' // redux/count_reducer.js import &amp;#123; INCREMENT, DECREMENT &amp;#125; from './constant' //初始化状态 const initState = 0 export default function countReducer(preState = initState, action) &amp;#123; const &amp;#123; type, data &amp;#125; = action switch (type) &amp;#123; case INCREMENT: return preState + data case DECREMENT: return preState - data default: return preState &amp;#125; &amp;#125; // redux/store.js import &amp;#123; createStore &amp;#125; from 'redux' //引入为 Count 组件服务的 reducer import countReducer from './count_reducer' export default createStore(countReducer) // redux/count_action.js import &amp;#123; INCREMENT, DECREMENT &amp;#125; from './constant' export const createIncrementAction = (data) => (&amp;#123; type: INCREMENT, data &amp;#125;) export const createDecrementAction = (data) => (&amp;#123; type: DECREMENT, data &amp;#125;) // components/Count/index.jsx import React, &amp;#123; Component &amp;#125; from 'react' import store from '../../redux/store' import &amp;#123; createIncrementAction, createDecrementAction &amp;#125; from '../../redux/count_action' export default class Count extends Component &amp;#123; // 可在组件单独监听 Redux 状态变化 // componentDidMount() &amp;#123; // store.subscribe(() => &amp;#123; // this.setState(&amp;#123;&amp;#125;) // &amp;#125;) // &amp;#125; increment = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber // 将 value 转为数值 // 手动写 Action 对象 store.dispatch(&amp;#123; type: 'increment', data: value * 1 &amp;#125;) // 专门创建 Action 对象 store.dispatch(createIncrementAction(value * 1)) &amp;#125; decrement = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber store.dispatch(createDecrementAction(value * 1)) &amp;#125; incrementAsync = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber setTimeout(() => &amp;#123; store.dispatch(createIncrementAction(value * 1)) &amp;#125;, 500) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;h1>当前求和为：&amp;#123;store.getState()&amp;#125;&lt;/h1> &lt;select ref=&amp;#123;(c) => (this.selectNumber = c)&amp;#125;> &lt;option value=\"1\">1&lt;/option> &lt;option value=\"2\">2&lt;/option> &lt;option value=\"3\">3&lt;/option> &lt;/select> &lt;button onClick=&amp;#123;this.increment&amp;#125;>+&lt;/button> &lt;button onClick=&amp;#123;this.decrement&amp;#125;>-&lt;/button> &lt;button onClick=&amp;#123;this.incrementAsync&amp;#125;>异步加&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; Redux只负责管理状态，状态改变后页面的更新需要自己写 可以在index.js中监听状态变化，不能直接调render(),要用this.setState(&#123;&#125;)间接调用 reducer由store首次调用时传递的previousState是undefined，action为&#123;type:&#39;@@REDUX/INIT_a.5.v.9&#39;&#125;类似的东西，没有传data Redux异步编程安装异步中间件： npm install redux-thunk -S 要点： 延迟的动作不想交给组件，而是 action 当操作状态所需数据要靠异步任务返回时，可用异步 action 创建 action 的函数返回一个函数，该函数中写异步任务 异步任务完成后，分发一个同步 action 操作状态 异步 action 不是必要的，完全可以在组件中等待异步任务结果返回在分发同步 action // store.js import &amp;#123; createStore, applyMiddleware &amp;#125; from 'redux' import countReducer from './count_reducer' import thunk from 'redux-thunk' export default createStore(countReducer, applyMiddleware(thunk)) // count_action.js import &amp;#123; INCREMENT, DECREMENT &amp;#125; from './constant.js' export const createIncrementAction = (data) => (&amp;#123; type: INCREMENT, data &amp;#125;) export const createDecrementAction = (data) => (&amp;#123; type: DECREMENT, data &amp;#125;) // 异步 action 返回一个函数 export const createIncrementAsyncAction = (data, time) => &amp;#123; return (dispatch) => &amp;#123; setTimeout(() => &amp;#123; dispatch(createIncrementAction(data)) &amp;#125;, time) &amp;#125; &amp;#125; // Count.jsx incrementAsync = () => &amp;#123; const &amp;#123; value &amp;#125; = this.selectNumber store.dispatch(createIncrementAsyncAction(value * 1)) &amp;#125; 整个过程简单理解：store 在分发 action 时，发现返回一个函数，那它知道这是个异步 action 。因此 store 勉为其难地帮忙执行这个函数，同时给这个函数传递 dispatch 方法，等待异步任务完成取到数据后，直接调用 dispatch 方法分发同步 action 。","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"hexo博客主题与修改","slug":"hexo博客主题安装与修改","date":"2022-10-09T14:52:23.000Z","updated":"2022-10-26T02:00:53.589Z","comments":true,"path":"2022/10/09/hexo-bo-ke-zhu-ti-an-zhuang-yu-xiu-gai/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/hexo-bo-ke-zhu-ti-an-zhuang-yu-xiu-gai/","excerpt":"","text":"hexo博客主题安装与修改1.主题下载与安装点击下载地址下载master分支的最新稳定版的代码，解压缩后，将hexo-theme-matery的文件复制到hexo的theme文件夹中即可 当然你也可以在你的站点目录文件夹下使用 git clone 命令来下载：直接在站点根目录下执行下面的命令，即可进行主题的下载，主题有两个版本，稳定版本和最新版本(不定期更新优化)，自主选择版本。 git clone https://github.com/blinkfox/hexo-theme-matery themes/matery # 稳定版 git clone -b develop https://github.com/blinkfox/hexo-theme-matery themes/matery #最新版(不定期进行优化更新) 2.主题配置2.1 切换主题 进入根目录下的_config.yml中，往下滑到大概101行有一个theme，将它改为刚才你引入到根目录theme下的文件夹的名字就行，记得theme:后加一个空格即theme: 你引入的文件夹的名字（不用加引号） 语言选择：如果为中文用户，则在language:后添加值zh-CN，如果不修改，默认为英语；网址修改：url:的值为你的网址名，如http://xxxx.github.io，如果有域名，则修改为你的域名即可点配置文件有个per_page属性，建议修改为6的倍数，这样网站在适应设备时，有较好的显示效果。 2.2 新建页面 本次操作需要新建’tags’,’categories’,’about’,’contact’(留言板（可选）),’friends’(友情链接(可选))基本操作都是一样以’tags’为例 tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags&#x2F;index.md 文件，那么你就需要新建一个，命令如下 hexo new page \"tags\" 编辑你刚刚新建的页面文件 &#x2F;source&#x2F;tags&#x2F;index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 其他页面的新建也是如此，将tags改为对应的就行，如about，把上面的tags都改为about就行 tags和category用法你新建玩tags和category页面以后 在你写post中的md文件时在顶部加入以下代码 title: 10.5(React脚手架) categories: React tags: - React - 笔记 就会生成以下效果 新建friend页面后同时，在你的博客source目录下新建_data目录，在_data目录中新建friends.json文件，文件内容如下所示： [&amp;#123; \"avatar\": \"../avatars/1.jpg\", \"name\": \"灰色的小伊\", \"introduction\": \"来bilibili了解更多追番，冲冲冲\", \"url\": \"https://space.bilibili.com/244375982?spm_id_from=333.1007.0.0\", \"title\": \"前去学习\" &amp;#125;, &amp;#123; \"avatar\": \"../avatars/0.png\", \"name\": \"太阳\", \"introduction\": \"更多知识笔记，来语雀一起学习\", \"url\": \"https://www.yuque.com/dashboard/my_books\", \"title\": \"前去学习\" &amp;#125;, &amp;#123; \"avatar\": \"https://avatars.githubusercontent.com/u/100678707?v=4\", \"name\": \"engravesunny\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://github.com/Engravesunny\", \"title\": \"前去学习\" &amp;#125;] 2.3菜单导航配置 1.菜单导航名称可以是中文也可以是英文(如：Index或主页)2.图标icon 可以在Font Awesome 中查找 在你引入的主题文件夹中的_config.yml中更改以下代码 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 以上是一级菜单二级菜单配置方法：1.在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)2.在children下创建二级菜单的 名称name,路径url和图标icon.3.注意每个二级菜单模块前要加 -.4.注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 2.4代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 2.5 搜索 本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save search: path: search.xml field: post 2.6中文链接转拼音（可选的） 如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 npm i hexo-permalink-pinyin --save permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 2.7 文章字数统计插件（可选的） 如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可： wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 2.8 添加 DaoVoice 在线聊天功能（可选的） 前往 DaoVoice官网注册并且获取app_id，并将app_id填入主题的_config.yml 文件中 2.9 添加 Tidio 在线聊天功能（可选的） 前往 Tidio官网注册并且获取Public Key，并将Public Key填入主题的_config.yml 文件中。 2.10 修改页脚 页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 &#x2F;layout&#x2F;_partial&#x2F;footer.ejs 文件中，包括站点、使用的主题、访问量等。 2.11 修改社交链接 在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 &#x2F;layout&#x2F;_partial&#x2F;social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) &amp;#123; %> &lt;a href=\"&lt;%= theme.socialLink.github %>\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"> &lt;i class=\"fab fa-github\">&lt;/i> &lt;/a> &lt;% &amp;#125; %> 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebookTwitter: fab fa-twitterGoogle-plus: fab fa-google-plusLinkedin: fab fa-linkedinTumblr: fab fa-tumblrMedium: fab fa-mediumSlack: fab fa-slackSina Weibo: fab fa-weiboWechat: fab fa-weixinQQ: fab fa-qqZhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0 2.12 修改打赏的二维码图片 在主题文件的 source&#x2F;medias&#x2F;reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片.2.13 配置音乐播放器（可选的） 要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。 首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json 文件，文件内容如下所示： [&amp;#123; \"name\": \"五月雨变奏电音\", \"artist\": \"AnimeVibe\", \"url\": \"http://xxx.com/music1.mp3\", \"cover\": \"http://xxx.com/music-cover1.png\" &amp;#125;, &amp;#123; \"name\": \"Take me hand\", \"artist\": \"DAISHI DANCE,Cecile Corbel\", \"url\": \"/medias/music/music2.mp3\", \"cover\": \"/medias/music/cover2.png\" &amp;#125;, &amp;#123; \"name\": \"Shape of You\", \"artist\": \"J.Fla\", \"url\": \"http://xxx.com/music3.mp3\", \"cover\": \"http://xxx.com/music-cover3.png\" &amp;#125;] 注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面 然后，在主题的 _config.yml 配置文件中激活配置即可： # 是否在首页显示音乐. music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 3.文章 Front-matter 介绍 Front-matter 选项详解 Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 最简示例 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例 --- title: typora-vue-theme主题介绍 date: 2022-05-02 09:25:00 author: CrazyYu img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 4.效果截图 最新版本进行了优化更新，效果图与最初的效果图有差别，下面的图不是最新版本的。 今天先到这，我也要洗澡睡觉了(23:44)","categories":[{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"}]},{"title":"搭建hexo博客","slug":"10.8-10.9笔记","date":"2022-10-09T14:18:22.000Z","updated":"2022-10-09T14:51:00.800Z","comments":true,"path":"2022/10/09/10.8-10.9-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.8-10.9-bi-ji/","excerpt":"","text":"简单博客搭建流程这两天主要就是在搭建和配置自己的小博客(以后会发一点博文，不过我大多会是笔记本来用) 本地安装以及发布 安装到本地 首先选择一个磁盘作为你博客文件的存放位置，然后新建一个文件夹，比如名为blogtest的文件夹，创建完后，先不要点进去，在此处点击鼠标右键，选择Git Bash Here，然后依次输入如下命令： # hexo框架的安装 npm install -g hexo-cli # 等上一个命令完成后，在输入下面的命令 hexo init &lt;新建文件夹的名称> #初始化文件夹 cd &lt;新建文件夹的名称> npm install # 安装博客所需要的依赖文件 等待运行完的时候，此时文件夹里多了很多文件注意：后续的命令都在站点目录下使用Git Bash运行此时Hexo框架的本地搭建已经完成了。命令行依次输入以下命令: hexo g hexo s 浏览器中打开它执行完后给你的地址（默认为http://localhost:4000/），可以看到一个网页，说明Hexo已经成功在本地运行 2.本地博客发布到Github Pages 首先安装可以用来发布的插件，在站点目录下执行以下命令: npm install hexo-deployer-git --save 然后把本地目录与GitHub关联起来，输入以下命令行: ssh-keygen -t rsa -C '你的邮箱地址' 然后一直回车找到C:&#x2F;Users&#x2F;[username]目录下名为.ssh的文件夹，文件夹内会有两个文件，一个id_rsa.pub一个id_rsa，用文本编辑器打开id_rsa.pub，复制里面的的内容。 然后打开Github，点击右上角的头像 Settings 选择SSH and GPG keys 点击New SSH key 将之前复制的内容粘帖到Key的框中。 上面的Title可以随意，点击Add SSH key 完成添加。 然后回到命令行界面，测试一下是否与github连接成功 ssh -T git@github.com 点击回车，然后会出现一个询问内容，输入yes，回车，会出现一段内容，Hi ! You’ve successfully authenticated, but GitHub doesnot provide shell access.。 说明连接成功。此处这个应该是你Github的用户名。 进入博客站点目录，用文本编辑器打开_config.yml，这个_config.yml是博客的配置文件，在以后的博客修改，如个性化修改，博客SEO优化等都会使用到， 修改如下图的几个地方： title: 你的博客名 subtitle: 博客的副标题，有些主题支持 description: 博客描述 keywords: 博客关键词 author: 作者，在文章中显示 language: 博客语言语种 timezone: 时区 滑到文件最底部，有一个deploy，在deploy下面添加一个repo项 ，一个branch项。填入如下代码，并如下图所示 type: git repo: git@github.com:Github用户名/github用户名.github.io.git //也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git branch: master 最后就是生成页面，并发布至Github Pages，执行如下命令： # Hexo会根据配置文件渲染出一套静态页面 hexo g # 将上一步渲染出的一系列文件上传至至Github Pages hexo d # 也可以直接输入此命令，直接完成渲染和上传 hexo g -d hexo博客主题的安装于修改会在另一篇里专门讲","categories":[{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"10.1-3笔记","slug":"10.1-3笔记","date":"2022-10-09T01:25:00.000Z","updated":"2022-10-09T08:30:29.275Z","comments":true,"path":"2022/10/09/10.1-3-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.1-3-bi-ji/","excerpt":"","text":"从今天开始学习React了！！（2022.10.01）jsx语法规则 1.定义虚拟DOM时，不要用引号 2.标签中混用JS表达式时要用&#123;&#125; 3.样式的类名指定不要用class，要用className 4.内联样式，要用style=&#123;&#123;key:value&#125;&#125;的形式去写 5.只有一个跟标签 6.标签必须闭合 7.标签首字母 (1).若小写字母开头，则将该标签转为html中同名元素，若html中没有该标签，就报错 (2).如果是大写字母开头，React就去渲染这个组件，没有定义的话就报错 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;style> .pink&amp;#123; background-color: pink; &amp;#125; &lt;/style> &lt;/head> &lt;body> &lt;div id=\"test\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> /* 此处一定要写babel */ //1.创建虚拟DOM const x = '外部定义的变量' const id = 'title' const VDOM = ( &lt;div> &lt;h1 id=&amp;#123;id&amp;#125; className=\"pink\" style=&amp;#123;&amp;#123;color:'white'&amp;#125;&amp;#125;>Hello,React&lt;/h1> &lt;span>&amp;#123;x&amp;#125;&lt;/span> &lt;/div> ) //此处一定不要写引号，因为不是字符串 //2.渲染虚拟DOM到页面 // ReactDOM.render(虚拟DOM,容器) ReactDOM.render(VDOM,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> 2.state属性组件内定义state属性&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\"> &lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; constructor(props)&amp;#123; super(props) this.state=&amp;#123; isHot:false, wind:'大风' &amp;#125; &amp;#125; render()&amp;#123; return &lt;h1>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> state事件绑定&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\"> &lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; // 构造器调用1次 constructor(props)&amp;#123; console.log('constructor'); super(props) this.state=&amp;#123; isHot:false, wind:'大风' &amp;#125; //解决clickFn中this指向问题 this.clickFn=this.clickFn.bind(this) &amp;#125; // render调用1+n次 1是初始化那次，n是状态更新的次数 render()&amp;#123; return &lt;h1 onClick=&amp;#123;this.clickFn&amp;#125;>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; // 类内定义函数 clickFn()&amp;#123; // clickFn放在了Weather的原型对象上，供示例使用 // 由于clickFn是作为onClick的回调，所以不是通过实例调用的，是直接调用 // 类中的方法默认开启严格模式，所以clickFn中的this为undefined let isHot = this.state.isHot // 严重注意：状态(state)不可以直接修改，下面这行就是直接更改！！！ // this.state.isHot = !isHot console.log(this); // 严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换 this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) // 类外定义函数 // let clickFn = function()&amp;#123; // alert('被点击了') // &amp;#125; // console.log(clickFn); // let clickFn = ()=>&amp;#123; // alert('被点击了') // &amp;#125; // console.log(clickFn); // 测试了一下，上面两种方式没办法执行，不知道是jsx的问题还是我哪里的知识点落下了 —_— // function clickFn()&amp;#123; // alert('h1被点击了') // &amp;#125; // //上面这种是可以的 &lt;/script> &lt;/body> &lt;/html> state简写&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;!-- 先准备好一个容器 --> &lt;div id=\"test\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;script type=\"text/babel\"> //创建一个组件 class Wether extends React.Component&amp;#123; //直接放到实例自身上 state=&amp;#123; isHot:false, wind:'大风' &amp;#125; // render调用1+n次 1是初始化那次，n是状态更新的次数 render()&amp;#123; return &lt;h1 onClick=&amp;#123;this.clickFn&amp;#125;>今天天气很&amp;#123;this.state.isHot?'炎热':'凉爽'&amp;#125;,今天有&amp;#123;this.state.wind&amp;#125;&lt;/h1> &amp;#125; // 自定义方法——要用赋值语句的形式+箭头函数 clickFn = ()=> &amp;#123; let isHot = this.state.isHot console.log(this); this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; &amp;#125; ReactDOM.render(&lt;Wether/>,document.getElementById('test')) &lt;/script> &lt;/body> &lt;/html> state总结1.state是组件对象最重要的属性，值是对象2.通过更新组件的state来更新对应的页面显示 注意1.组件中的render方法中的this为组件实例对象2.组件自定义方法中的this为undefined，如何解决？ 1)强制绑定this：通过函数对象的bind() 2)箭头函数3.状态数据，不能直接修改或更新 props属性props基本使用&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div id=\"test1\">&lt;/div> &lt;div id=\"test2\">&lt;/div> &lt;div id=\"test3\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;!-- prop-types库 --> &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> class Person extends React.Component&amp;#123; render()&amp;#123; const &amp;#123;name,age,sex&amp;#125; = this.props return &lt;ul> &lt;li>姓名：&amp;#123;name&amp;#125;&lt;/li> &lt;li>年龄：&amp;#123;age&amp;#125;&lt;/li> &lt;li>性别：&amp;#123;sex&amp;#125;&lt;/li> &lt;/ul> &amp;#125; &amp;#125; //对标签属性进行类型，必要性的限制 Person.propTypes = &amp;#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &amp;#125; // 指定默认标签属性值 Person.defaultProps = &amp;#123; sex:'不男不女' &amp;#125; ReactDOM.render(&lt;Person name='jerry' age=&amp;#123;19&amp;#125; />,document.getElementById('test1')) ReactDOM.render(&lt;Person name='tom' age=&amp;#123;18&amp;#125; sex='男' />,document.getElementById('test2')) //批量传递标签属性 const p = &amp;#123;name:'jane' ,age:19, sex:'女' &amp;#125; ReactDOM.render(&lt;Person &amp;#123;...p&amp;#125; />,document.getElementById('test3')) &lt;/script> &lt;/body> &lt;/html> props的简写方法&lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> &lt;div id=\"test1\">&lt;/div> &lt;div id=\"test2\">&lt;/div> &lt;div id=\"test3\">&lt;/div> &lt;!-- 引入react核心库 --> &lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\">&lt;/script> &lt;!-- 引入react-dom，用于支持react操作dom --> &lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\">&lt;/script> &lt;!-- 引入babel，用于将jsx转为js --> &lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\">&lt;/script> &lt;!-- prop-types库 --> &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> class Person extends React.Component&amp;#123; //对标签属性进行类型，必要性的限制 static propTypes = &amp;#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &amp;#125; // 指定默认标签属性值 static defaultProps = &amp;#123; sex:'不男不女' &amp;#125; render()&amp;#123; const &amp;#123;name,age,sex&amp;#125; = this.props return &lt;ul> &lt;li>姓名：&amp;#123;name&amp;#125;&lt;/li> &lt;li>年龄：&amp;#123;age&amp;#125;&lt;/li> &lt;li>性别：&amp;#123;sex&amp;#125;&lt;/li> &lt;/ul> &amp;#125; &amp;#125; ReactDOM.render(&lt;Person name='jerry' age=&amp;#123;19&amp;#125; />,document.getElementById('test1')) ReactDOM.render(&lt;Person name='tom' age=&amp;#123;18&amp;#125; sex='男' />,document.getElementById('test2')) //批量传递标签属性 const p = &amp;#123;name:'jane' ,age:19, sex:'女' &amp;#125; ReactDOM.render(&lt;Person &amp;#123;...p&amp;#125; />,document.getElementById('test3')) &lt;/script> &lt;/body> &lt;/html>","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Alicia"},{"title":"10.4(props)笔记","slug":"10.4笔记","date":"2022-10-09T01:25:00.000Z","updated":"2022-10-09T08:30:38.322Z","comments":true,"path":"2022/10/09/10.4-bi-ji/","link":"","permalink":"http://engravesunny.github.io/2022/10/09/10.4-bi-ji/","excerpt":"","text":"props(继续学习)类式组件的构造器与props构造函数一般用在两种情况: 1.通过给this.state赋值对象来初始化内部state 2.为事件处理函数绑定实例 constructor(props)&amp;#123; super(props) //初始化state this.state=&amp;#123;isHot:true,wind:'微风'&amp;#125; // 解决 this 指向问题 this.changeWeather = this.changeWeather.bind(this) &amp;#125; 因此构造器一般不需要写，如果要在构造器内使用this.props才声明构造器,并且需要在最开始调用super(props) constructor(props)&amp;#123; super(props) console.log(this.props); &amp;#125; 函数式组件与props由于函数可以传递参数，因此函数式组件可以使用 props 。 &lt;script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\">&lt;/script> &lt;script type=\"text/babel\"> // 因为函数可以传参数，因此函数式组件可以使用props function Person(props)&amp;#123; const &amp;#123; name, age, sex &amp;#125; = props return ( &lt;ul> &lt;li>姓名：&amp;#123; name &amp;#125;&lt;/li> &lt;li>年龄：&amp;#123; age &amp;#125;&lt;/li> &lt;li>性别：&amp;#123; sex &amp;#125; &lt;/li> &lt;/ul> ) &amp;#125; Person.propTypes = &amp;#123; name:PropTypes.string.isRequired, age:PropTypes.number, sex:PropTypes.string, &amp;#125; Person.defaultProps = &amp;#123; sex:'男', age:18 &amp;#125; ReactDOM.render(&lt;Person name=\"tom\"/>,document.getElementById('test')) &lt;/script> 组件实例核心属性3–ref字符串类型的ref这种形式已过时，效率不高，官方不建议使用 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; showLeft = ()=> &amp;#123; const &amp;#123;ipt1&amp;#125; = this.refs alert(ipt1.value) &amp;#125; showRight = ()=> &amp;#123; const &amp;#123;ipt2&amp;#125; = this.refs alert(ipt2.value) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref='ipt1' type=\"text\" placeholder=\"点我提示左侧信息\"/> &lt;button onClick=&amp;#123;this.showLeft&amp;#125;>点我提示左侧信息&lt;/button> &lt;input onBlur=&amp;#123;this.showRight&amp;#125; ref='ipt2' type=\"text\" placeholder=\"失去焦点提示右侧信息\"/> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 回调类型的ref要点： c =&gt; this.ipt1 = c就是给组件实例添加ipt1属性，值为节点 由于是箭头函数，因此this是render函数里的实例，即为组件实例 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; showLeft=()=>&amp;#123; const &amp;#123;ipt1&amp;#125; = this alert(ipt1.value) &amp;#125; showRight=()=>&amp;#123; const &amp;#123;ipt2&amp;#125; = this alert(ipt2.value) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref=&amp;#123;c=>this.ipt1=c&amp;#125; type=\"text\" placeholder='点击获取左侧信息' /> &lt;button onClick=&amp;#123;this.showLeft&amp;#125;>点我获取左侧信息&lt;/button> &lt;input onBlur=&amp;#123;this.showRight&amp;#125; ref=&amp;#123;c=>this.ipt2=c&amp;#125; type=\"text\" placeholder='失去焦点提示右侧信息'/> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 关于回调 ref 执行次数的问题，官网 (opens new window)描述： TIP如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 即内联函数形式，在更新过程中 ref 回调会被执行两次，第一次传入 null ，第二次传入 DOM 元素。若是下述形式，则只执行一次。但是对功能实现没有影响，因此一般也是用内联函数形式。 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state=&amp;#123; isHot:true &amp;#125; changeWeather = ()=>&amp;#123; const isHot = this.state.isHot this.setState(&amp;#123;isHot:!isHot&amp;#125;) &amp;#125; showMsg = ()=>&amp;#123; const &amp;#123;ipt&amp;#125; = this alert(ipt.value) &amp;#125; saveRefs = (c)=>&amp;#123; &amp;#125; render()&amp;#123; const &amp;#123;isHot&amp;#125; = this.state return ( &lt;div> &lt;h2>&amp;#123;isHot?'炎热':'凉爽'&amp;#125;&lt;/h2> &amp;#123;/*&lt;input ref=&amp;#123;c=>&amp;#123;this.ipt=c;console.log('@',c)&amp;#125;&amp;#125; type=\"text\"/> &lt;br/>&lt;br/>*/&amp;#125; //上面回调在render更新渲染时会调用两次 //解决：外层定义一个save函数，ref回调里调用save，save里提取真实DOM &lt;input ref=&amp;#123;this.saveRefs&amp;#125; type=\"text\"/> &lt;br/>&lt;br/> &lt;button onClick=&amp;#123;this.showMsg&amp;#125;>点我提示信息&lt;/button> &lt;button onClick=&amp;#123;this.changeWeather&amp;#125;>切换&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> createRef API该方式通过调用React.CreateRef返回一个容器用于储存节点，且一个容器只能存储一个节点 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; myRef = React.createRef() showMsg = ()=>&amp;#123; console.log(this.myRef.current.value); &amp;#125; render()&amp;#123; return ( &lt;div> &lt;input ref=&amp;#123;this.myRef&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.showMsg&amp;#125;>点击提示信息&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 事件处理 React 使用自定义事件，而非原生 DOM 事件，即 onClick、onBlur ：为了更好的兼容性 React 的事件通过事件委托方式进行处理：为了高效 通过 event.target 可获取触发事件的DOM元素：勿过度使用 ref 当触发事件的元素和需要操作的元素为同一元素时，可以不使用ref: class Demo extends React.Component &amp;#123; showData2 = (event) => &amp;#123; alert(event.target.value) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;input onBlur=&amp;#123;this.showData2&amp;#125; type=\"text\" placeholder=\"失去焦点提示数据\" /> &amp;nbsp; &lt;/div> ) &amp;#125; &amp;#125;","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Alicia"},{"title":"10.5(React脚手架)","slug":"10.5(2)","date":"2022-10-08T08:00:44.726Z","updated":"2022-10-09T08:31:48.382Z","comments":true,"path":"2022/10/08/10.5-2/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.5-2/","excerpt":"","text":"React脚手架React脚手架项目结构public:静态资源文件 manifest.json:应用加壳(把网页变成安卓&#x2F;ios软件)的配置文件 robots.txt:爬虫协议文件 src:源码文件 App.test.js:用于给App组件做测试 index.js:入口文件 reportWebVitals.js:页面性能分析文件，需要web-vitals支持 setupTests.js:组件单元测试文件，需要jest-dom支持 index.js代码分析: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"utf-8\" /> &lt;!-- %PUBLIC_URL% 代表 public 文件夹的路径 --> &lt;link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" /> &lt;!-- 开启理想视口，用于做移动端网页的适配 --> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /> &lt;!-- 用于配置浏览器页签+地址栏的颜色(仅支持安卓手机浏览器) --> &lt;meta name=\"theme-color\" content=\"red\" /> &lt;!-- 网站描述 --> &lt;meta name=\"description\" content=\"Web site created using create-react-app\" /> &lt;!-- 用于指定网页添加到手机主屏幕后的图标 --> &lt;link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" /> &lt;!-- 应用加壳时的配置文件 --> &lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" /> &lt;title>React App&lt;/title> &lt;/head> &lt;body> &lt;!-- 若浏览器不支持 js 则展示标签中的内容 --> &lt;noscript>You need to enable JavaScript to run this app.&lt;/noscript> &lt;div id=\"root\">&lt;/div> &lt;/body> &lt;/html> 样式的模块化样式的模块化可用于解决样式冲突的问题。该方法比较麻烦，实际开发用的比较少。用 less 就能解决了。component/Hello文件下的index.css改名为index.module.css .title&amp;#123; background-color:pink; &amp;#125; Hello组件导入样式: import &amp;#123; Component &amp;#125; from 'react' import hello from './index.module.css' export default class Hello extends Component &amp;#123; render() &amp;#123; return &lt;h2 className=&amp;#123;hello.title&amp;#125;>Hello,React!&lt;/h2> &amp;#125; &amp;#125; React网络请求React脚手架配置代理方法一： 在package.json文件中进行配置: \"proxy\":\"http://localhost:5000\" //要访问的url 优点：配置简单，前端请求资源不加前缀 缺点：不能配置多个代理 工作方式：当请求了3000端口（本机）不存在的资源时，就会把请求转发给5000端口号服务器 方法二： 在src目录下创建代理配置文件setupProxy.js，进行配置： const proxy = require('http-proxy-middleware') module.exports = function (app) &amp;#123; app.use( //api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000) proxy('/api1', &amp;#123; //配置转发目标地址(能返回数据的服务器地址) target: 'http://localhost:5000', //控制服务器接收到的请求头中host字段的值 /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000 changeOrigin默认值为false，但一般将changeOrigin改为true */ changeOrigin: true, //去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置) pathRewrite: &amp;#123; '^/api1': '' &amp;#125;, &amp;#125;), proxy('/api2', &amp;#123; target: 'http://localhost:5001', changeOrigin: true, pathRewrite: &amp;#123; '^/api2': '' &amp;#125;, &amp;#125;) ) &amp;#125;","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.7(React路由)","slug":"10.7","date":"2022-10-08T08:00:15.418Z","updated":"2022-10-09T08:32:00.421Z","comments":true,"path":"2022/10/08/10.7/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.7/","excerpt":"","text":"React路由路由的严格匹配与模糊匹配 默认使用模糊匹配（输入路径必须包含要匹配的路径，且顺序一致 开启严格模式：&lt;Route exact path=&#39;/about&#39; component=&#123;About&#125;/&gt; 严格匹配开启可能会导致无法继续匹配二级路由 Redirect的使用 一般写在所有路由注册的最下方，当所有路由无法匹配时，跳转到Redirect指定的路由 &lt;Switch> &lt;Route path=\"/about\" component=\"&amp;#123;About&amp;#125;\" /> &lt;Route path=\"/home\" component=\"&amp;#123;Home&amp;#125;\" /> &lt;Redirect to=\"/about\" /> &lt;/Switch> 嵌套路由 注册子路由上需要写父路由的path 路由的匹配是按照注册路由的顺序进行的 &lt;!-- 父组件 --> &lt;MyNavLink to=\"/about\">About&lt;/MyNavLink> &lt;MyNavLink to=\"/home\">Home&lt;/MyNavLink> &lt;Switch> &lt;Route path=\"/about\" component=\"&amp;#123;About&amp;#125;\" /> &lt;Route path=\"/home\" component=\"&amp;#123;Home&amp;#125;\" /> &lt;Redirect to=\"/about\" /> &lt;/Switch> &lt;!-- 子组件 --> &lt;ul className=\"nav nav-tabs\"> &lt;li> &lt;MyNavLink to=\"/home/news\">News&lt;/MyNavLink> &lt;/li> &lt;li> &lt;MyNavLink to=\"/home/message\">Message&lt;/MyNavLink> &lt;/li> &lt;/ul> &lt;Switch> &lt;Route path=\"/home/news\" component=\"&amp;#123;News&amp;#125;\" /> &lt;Route path=\"/home/message\" component=\"&amp;#123;Message&amp;#125;\" /> &lt;Redirect to=\"/home/news\" /> &lt;/Switch> 路由传参三种方式：params,search,state三种方式对比： state:在当前页面刷新可以保留参数，但在新页面刷新不能保留。前两种方式因为是在url地址上保存参数，因此地址都能保留 params和search参数都会变成字符串 &lt;!-- 路由链接 --> &lt;Link to='/home/message/detail/Bruce/21'>params&lt;/Link> &lt;Link to=&amp;#123;`/home/message/detail/$&amp;#123;item.name&amp;#125;/$&amp;#123;item.age&amp;#125;`&amp;#125;>&amp;#123;item.name&amp;#125;&lt;/Link> &lt;Link to='/home/message/detail/?name=Bruce&amp;age=21'>search&lt;/Link> &lt;Link to=&amp;#123;`/home/message/detail/?id=$&amp;#123;item.name&amp;#125;&amp;title=$&amp;#123;item.age&amp;#125;`&amp;#125;>&amp;#123;item.name&amp;#125;&lt;/Link> &lt;Link to=&amp;#123;&amp;#123;pathname: '/home/message/detail', state: &amp;#123;name: 'Bruce', age: 21&amp;#125;&amp;#125;&amp;#125;>state&lt;/Link> &lt;!-- 注册路由 --> &lt;Route path='/home/message/detail/:name/:age' component=&amp;#123;Detail&amp;#125; /> &lt;!-- search 和 state 按正常注册即可 --> &lt;Route path='/home/message/detail' component=&amp;#123;Detail&amp;#125; /> //接收参数 const &amp;#123; name, age &amp;#125; = this.props.match.params import qs from 'querystring' const &amp;#123; search &amp;#125; = this.props.location const &amp;#123; name, age &amp;#125; = qs.parse(search.slice(1)) const &amp;#123; name, age &amp;#125; = this.props.location.state 编程式导航编程式导航是使用路由组件this.props.history提供的API进行路由跳转 this.props.history.push(path,state) this.props.history.replace(path,state) this.props.history.goForward() this.props.history.gopBack() this.props.history.go(2)参数为负数时是后退 //编程式导航传参数 this.props.history.push(`/home/message/detail/$&amp;#123;id&amp;#125;/$&amp;#123;title&amp;#125;`)//params传参 this.props.history.push(`/home/message/detail?id=&amp;#123;id&amp;#125;&amp;title=&amp;#123;title&amp;#125;`)//search传参 this.props.history.push(`/home/message/detail`,&amp;#123;id,title&amp;#125;)//state传参 withRouter的使用withRouter的作用：加工一般组件，使其像路由组件一样有路由组件的API，如this.props.history等。 import React,&amp;#123;Component&amp;#125; from 'react' import &amp;#123;withRouter&amp;#125; from 'react-router-dom' class Header extends Component&amp;#123; ... &amp;#125; export default withRouter(Header) BrowserRouter和HashRouter底层原理不一样 BrowserRouter使用的是H5的history API，不兼容IE9及以下版本 HashRouter使用的是URL的哈希值 路径表现不一样 BrowserRouter的路径中没有#，如：localhost:3000&#x2F;demo&#x2F;test HashRouter的路径包含#，如：localhost:3000&#x2F;demo&#x2F;test 刷新会对路由state参数的影响 BrowserRouter没有影响，因为state保存在history对象中 HashRouter刷新后会导致路由state参数的丢失 备注:HashRouter可以解决一些路径错误相关的问题 React UI 组件库Ant Design 配置按需引入和自定义主题以下配置是 3.x 版本，4.x 版本见官网 1.安装依赖： npm install react-app-rewired customize-cra babel-plugin-import less less-loader 2.修改 package.json \"scripts\": &amp;#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-scripts eject\" &amp;#125; 3.根目录下创建 config-overrides.js //配置具体的修改规则 const &amp;#123; override, fixBabelImports, addLessLoader &amp;#125; = require('customize-cra') module.exports = override( fixBabelImports('import', &amp;#123; libraryName: 'antd', libraryDirectory: 'es', style: true, &amp;#125;), addLessLoader(&amp;#123; lessOptions: &amp;#123; javascriptEnabled: true, modifyVars: &amp;#123; '@primary-color': 'green' &amp;#125;, &amp;#125;, &amp;#125;) ) 备注：不用在组件里引入样式，import ‘antd&#x2F;dist&#x2F;antd.css’ 删掉","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.6(Github案例总结)","slug":"10.6","date":"2022-10-08T08:00:15.406Z","updated":"2022-10-09T08:31:55.013Z","comments":true,"path":"2022/10/08/10.6/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.6/","excerpt":"","text":"Github搜索框案例知识点总结 设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办 ES6知识点：解构赋值+重命名 let obj = &amp;#123; a: &amp;#123; b: 1 &amp;#125; &amp;#125; //传统解构赋值 const &amp;#123; a &amp;#125; = obj //连续解构赋值 const &amp;#123; a: &amp;#123; b &amp;#125;, &amp;#125; = obj //连续解构赋值 + 重命名 const &amp;#123; a: &amp;#123; b: value &amp;#125;, &amp;#125; = obj 初始代码Search组件import React, &amp;#123; Component &amp;#125; from 'react' import axios from 'axios'; import './index.css' export default class Search extends Component &amp;#123; search = ()=>&amp;#123; //获取用户的输入 console.log(this.keyWord.value); const keyword = this.keyWord.value this.props.updateState(&amp;#123;isFirst:false,isLoading:true&amp;#125;) //发送网络请求 axios.get(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`).then( res =>&amp;#123; this.props.updateState(&amp;#123;users:res.data.items,isLoading:false&amp;#125;) &amp;#125;, err =>&amp;#123; this.props.updateState(&amp;#123;isLoading:false,err:err.message&amp;#125;) &amp;#125; ) &amp;#125; render() &amp;#123; return ( &lt;div className='search'> &lt;h1>Search Github Users&lt;/h1> &lt;input ref=&amp;#123;c=>this.keyWord=c&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.search&amp;#125;>搜索&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; List组件import React, &amp;#123; Component &amp;#125; from 'react' import './Index.css' export default class List extends Component &amp;#123; render() &amp;#123; const &amp;#123;users,isFirst,isLoading,err&amp;#125; = this.props return ( &lt;div> &lt;ul> &amp;#123; isFirst ? &lt;h2>欢迎使用，输入关键字开始搜索&lt;/h2>: isLoading ? &lt;h2>Loading-------&lt;/h2>: err ? &lt;h2 style=&amp;#123;&amp;#123;color:'red'&amp;#125;&amp;#125;>&amp;#123;err&amp;#125;&lt;/h2>: users.map(item=>&amp;#123; return ( &lt;li key=&amp;#123;item.id&amp;#125;> &lt;a rel='noreferrer' href=&amp;#123;item.html_url&amp;#125; target='_blank'> &lt;img src=&amp;#123;item.avatar_url&amp;#125; alt=\"head_portrait\"/> &lt;p>&amp;#123;item.login&amp;#125;&lt;/p> &lt;/a> &lt;/li> ) &amp;#125;) &amp;#125; &lt;/ul> &lt;/div> ) &amp;#125; &amp;#125; App.jsimport React, &amp;#123; Component &amp;#125; from 'react'; import Search from './components/Search'; import List from './components/List'; export default class App extends Component &amp;#123; state = &amp;#123; users:[], isFirst:true, isLoading:false, err:'' &amp;#125; updateState = (stateObj)=>&amp;#123; this.setState(stateObj) &amp;#125; render() &amp;#123; return ( &lt;div> &lt;Search updateState=&amp;#123;this.updateState&amp;#125;>&lt;/Search> &lt;List &amp;#123;...this.state&amp;#125;>&lt;/List> &lt;/div> ); &amp;#125; &amp;#125; 3. 消息订阅与发布 限定月，再发布 适用于任意组件间通信 要在componentWillUnmount中取消订阅 使用PubSub代码Search组件(pubsub)import React, &amp;#123; Component &amp;#125; from 'react' import axios from 'axios'; import PubSub from 'pubsub-js'; import './index.css' export default class Search extends Component &amp;#123; search = ()=>&amp;#123; //获取用户的输入 console.log(this.keyWord.value); const keyword = this.keyWord.value // this.props.updateState(&amp;#123;isFirst:false,isLoading:true&amp;#125;) PubSub.publish('updateState',&amp;#123;isFirst:false,isLoading:true&amp;#125;) //发送网络请求 axios.get(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`).then( res =>&amp;#123; // this.props.updateState(&amp;#123;users:res.data.items,isLoading:false&amp;#125;) PubSub.publish('updateState',&amp;#123;users:res.data.items,isLoading:false&amp;#125;) &amp;#125;, err =>&amp;#123; // this.props.updateState(&amp;#123;isLoading:false,err:err.message&amp;#125;) PubSub.publish('updateState',&amp;#123;isLoading:false,err:err.message&amp;#125;) &amp;#125; ) &amp;#125; render() &amp;#123; return ( &lt;div className='search'> &lt;h1>Search Github Users&lt;/h1> &lt;input ref=&amp;#123;c=>this.keyWord=c&amp;#125; type=\"text\"/> &lt;button onClick=&amp;#123;this.search&amp;#125;>搜索&lt;/button> &lt;/div> ) &amp;#125; &amp;#125; List组件(pubsub)import React, &amp;#123; Component &amp;#125; from 'react' import PubSub from 'pubsub-js' import './Index.css' export default class List extends Component &amp;#123; state = &amp;#123; users:[], isFirst:true, isLoading:false, err:'' &amp;#125; componentDidMount()&amp;#123; this.token = PubSub.subscribe('updateState',(_,data)=>&amp;#123; console.log(data); this.setState(data) &amp;#125;) &amp;#125; componentWillUnmount()&amp;#123; PubSub.unsubscribe(this.token) &amp;#125; render() &amp;#123; const &amp;#123;users,isFirst,isLoading,err&amp;#125; = this.state return ( &lt;div> &lt;ul> &amp;#123; isFirst ? &lt;h2>欢迎使用，输入关键字开始搜索&lt;/h2>: isLoading ? &lt;h2>Loading-------&lt;/h2>: err ? &lt;h2 style=&amp;#123;&amp;#123;color:'red'&amp;#125;&amp;#125;>&amp;#123;err&amp;#125;&lt;/h2>: users.map(item=>&amp;#123; return ( &lt;li key=&amp;#123;item.id&amp;#125;> &lt;a rel='noreferrer' href=&amp;#123;item.html_url&amp;#125; target='_blank'> &lt;img src=&amp;#123;item.avatar_url&amp;#125; alt=\"head_portrait\"/> &lt;p>&amp;#123;item.login&amp;#125;&lt;/p> &lt;/a> &lt;/li> ) &amp;#125;) &amp;#125; &lt;/ul> &lt;/div> ) &amp;#125; &amp;#125; App.js(pubsub)import React, &amp;#123; Component &amp;#125; from 'react'; import Search from './components/Search'; import List from './components/List'; export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;Search>&lt;/Search> &lt;List>&lt;/List> &lt;/div> ); &amp;#125; &amp;#125; 4.fetch发送请求(关注分离的设计思想) try &amp;#123; //先看看服务器能不能连上 const response = await fetch(`https://api.github.com/search/users?q=$&amp;#123;keyword&amp;#125;`) //在获取数据 const data = await response.json() PubSub.publish('updateState',&amp;#123;users:data.items,isLoading:false&amp;#125;) console.log(data); &amp;#125; catch (error) &amp;#123; console.log('请求出错',error); PubSub.publish('updateState',&amp;#123;isLoading:false,err:error.message&amp;#125;) &amp;#125; React 路由路由的理解何为路由 一个路由是一个映射关系 key 为路径，value 可能是 function 或 组件 后端路由： value 是 function ，用于处理客户端的请求 注册路由：router.get(path, function(req, res)) 工作过程：Node 接收到请求，根据路径匹配路由，调用对应函数处理请求，返回响应数据 前端路由： value 是组件 注册路由：&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt; 工作过程：浏览器路径变为/test ，展示 Test 组件 路由的基本使用导航区用&lt;Link&gt;,展示区用&lt;Route&gt; import React, &amp;#123; Component &amp;#125; from 'react'; import &amp;#123; Link , Route &amp;#125; from 'react-router-dom'; import Home from './components/Home' import About from './components/About' import './index.css' export default class App extends Component &amp;#123; render() &amp;#123; return ( &lt;div> &lt;div className=\"header\"> &lt;h1>React Router Demo&lt;/h1> &lt;/div> &lt;div className=\"native\"> &amp;#123;/* &lt;a href=\"#\">About&lt;/a> &lt;a href=\"#\">Home&lt;/a> */&amp;#125; &lt;div className=\"linkArea\"> &lt;Link className='link1 active' to=\"/about\">About&lt;/Link> &lt;Link className='link2' to=\"/home\">Home&lt;/Link> &lt;/div> &lt;/div> &lt;div className=\"view\"> &lt;Route path=\"/about\" component=&amp;#123;About&amp;#125; /> &lt;Route path=\"/home\" component=&amp;#123;Home&amp;#125; /> &lt;/div> &lt;/div> ); &amp;#125; &amp;#125; &lt;App&gt;最外侧包裹&lt;BrowserRouter&gt;或&lt;HashRouter&gt;: import React from \"react\"; import ReactDOM from \"react-dom\"; import &amp;#123; BrowserRouter &amp;#125; from \"react-router-dom\"; import App from \"./App\"; ReactDOM.render( &lt;BrowserRouter>&lt;App>&lt;/App>&lt;/BrowserRouter>, document.getElementById('root')) 路由组件和一般组件1.写法不同： 一般组件：&lt;Demo/&gt; 路由组件：&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt; 2.存放位置不同： 一般组件：components 路由组件：pages 3.接收到的props不同： 一般组件：标签属性传递 路由组件：接收到三个固定的属性 history: go: ƒ go(n) goBack: ƒ goBack() goForward: ƒ goForward() push: ƒ push(path, state) replace: ƒ replace(path, state) location: pathname: \"/home/message/detail/2/hello\" search: \"\" state: undefined match: params: &amp;#123;&amp;#125; path: \"/home/message/detail/:id/:title\" url: \"/home/message/detail/2/hello\" NavLinkNavLink可以实现由链接的高亮，通过activeCassName指定样式名，默认追加类名为active &lt;NavLink activeClassName=\"demo\" to=\"/about\">About&lt;/NavLink> &lt;NavLink activeClassName=\"demo\" to=\"/home\">Home&lt;/NavLink> 封装NavLink组件:由于NavLink组件中的重复代码太多，因此进行二次封装※ 细节点：组件标签的内容会传递到 this.props.children属性中，反过来通过指定标签的 children 属性可以修改组件标签内容 // MyNavLink 组件 import React, &amp;#123; Component &amp;#125; from 'react' import &amp;#123; NavLink &amp;#125; from 'react-router-dom' export default class MyNavLink extends Component &amp;#123; render() &amp;#123; // this.props.children 可以取到标签内容，如 About, Home // 反过来通过指定标签的 children 属性可以修改标签内容 return &lt;NavLink activeClassName=\"demo\" className=\"list-group-item\" &amp;#123;...this.props&amp;#125; /> &amp;#125; &amp;#125; &lt;MyNavLink to=\"/about\">About&lt;/MyNavLink> &lt;MyNavLink to=\"/home\">Home&lt;/MyNavLink> Switch 的使用Switch可以提高路由匹配效率，如果匹配成功，则不再继续匹配后面的路由，即为单一匹配 &lt;Switch> &lt;Route path='/about' component=&amp;#123;About&amp;#125;/> &lt;Route path='/home' component=&amp;#123;Home&amp;#125;/> &lt;Route path='/home' component=&amp;#123;Test&amp;#125;/> &lt;/Switch> 解决多级路径刷新页面样式丢失的问题 public/index.html 中引入样式时不写./写/（常用） public/index.html中引入样式时不写./写%PUBLIC_URL%（常用） 使用HashRouter &lt;link rel=\"stylesheet\" href=\"/css/bootstrap.css\" /> &lt;link rel=\"stylesheet\" href=\"%PUBLIC_URL%/css/bootstrap.css\" />","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"10.5(受控非受控组件)","slug":"10.5","date":"2022-10-08T07:59:55.168Z","updated":"2022-10-09T08:31:40.321Z","comments":true,"path":"2022/10/08/10.5/","link":"","permalink":"http://engravesunny.github.io/2022/10/08/10.5/","excerpt":"","text":"受控 &amp; 非受控组件包含表单的组件分类： 非受控组件：现用现取。即需要时使用，再获取节点得到数据 受控组件：类似于Vue双向绑定的从视图层绑定到数据 尽量使用受控组件，因为非受控组件要使用大量的ref //非受控组件 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; handleSubmit = (event)=>&amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this alert( `您的用户名为$&amp;#123;username.value&amp;#125;，密码为$&amp;#123;password.value&amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123; this.handleSubmit &amp;#125;> 用户名：&lt;input ref=&amp;#123;c=>this.username=c&amp;#125; type=\"text\" name='username'/>&lt;br/> 密码 ：&lt;input ref=&amp;#123;c=>this.password=c&amp;#125; type=\"password\" name='password'/>&lt;br/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render( &lt;Demo>&lt;/Demo>,document.getElementById('test') ) &lt;/script> //受控组件 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveUserName = (event)=> &amp;#123; this.setState(&amp;#123;username:event.target.value&amp;#125;) &amp;#125; savePassword = (event)=> &amp;#123; this.setState(&amp;#123;password:event.target.value&amp;#125;) &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;this.saveUserName&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;this.savePassword&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 高阶函数_函数柯里化对上述受控组件代码进行优化，希望把saveUserName和savePassword合并为一个函数要点： 高阶函数：参数为函数或者返回一个函数的函数，如Promise、setTimeout、Array.map() 函数柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 //函数柯里化 function sum(a)&amp;#123; return (b)=>&amp;#123; return (c)&amp;#123; return a + b + c; &amp;#125; &amp;#125; &amp;#125; //使用高阶函数和函数柯里化 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveFormData = (dataType)=>&amp;#123; return (event)=>&amp;#123; this.setState(&amp;#123;[dataType]:event.target.value&amp;#125;) &amp;#125; &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;this.saveFormData('username')&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;this.saveFormData('password')&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> //不使用柯里化写法 &lt;script type=\"text/babel\"> class Demo extends React.Component&amp;#123; state = &amp;#123; username:'', password:'' &amp;#125; saveFormData = (dataType,event)=>&amp;#123; this.setState(&amp;#123;[dataType]:event.target.value&amp;#125;) &amp;#125; handleSubmit = (event)=> &amp;#123; event.preventDefault(); const &amp;#123;username,password&amp;#125; = this.state; alert( `您的用户名为$&amp;#123; username &amp;#125;,密码为$&amp;#123; password &amp;#125;` ) &amp;#125; render()&amp;#123; return ( &lt;div> &lt;form onSubmit=&amp;#123;this.handleSubmit&amp;#125;> &lt;input onChange=&amp;#123;event=>this.saveFormData('username',event)&amp;#125; type=\"text\"/> &lt;input onChange=&amp;#123;event=>this.saveFormData('password',event)&amp;#125; type=\"password\"/> &lt;button>登录&lt;/button> &lt;/form> &lt;/div> ) &amp;#125; &amp;#125; ReactDOM.render(&lt;Demo/>,document.getElementById('test')) &lt;/script> 生命周期生命周期旧版初始化阶段：ReactDOM.render()触发的初次渲染 constructor componentWillMount render componentDidMount &#x3D;&#x3D;&#x3D;&gt; 常用 一般在这个钩子中做一些初始化的事：如：开启定时器，发送网络请求，订阅消息 更新阶段： 1.父组件重新render触发的更新 componentWillReceiveProps shouldComponentUpdate ：控制组件是否更新的阀门，返回值为布尔值，默认为true。若返回 false ，则后续流程不会进行。 componentWillUpdate render componentDidUpdate 2.组件内部调用this.setState()修改状态 shouldComponentUpdate componentWillUpdate render componentDidUpdate 3.组件内部调用this.forceUpdate()强制更新 componentWillUpdate render componentDidUpdate &#x3D;&#x3D;&#x3D;&gt; 常用 一般在这个钩子里做一些收尾的事，例如：关闭定时器，取消订阅消息 卸载阶段:ReactDOM.unmountComponentAtNode()触发 componentWillUnmount 生命周期新版更改内容 废弃三个钩子：componentWillMount、componentWillReceiveProps、componentWillUpdate。在新版本中这三个钩子需要加UNSAFE_前缀，后续可能会废弃 新增两个钩子（实际场景用的很少）：getDerivedStateFromProps、getSnapshotBeforeUpdate static getDerivedStateFromProps(props, state)： 需使用 static 修饰 需返回一个对象更新 state或返回 null 适用于如下情况：state 的值任何时候都取决于prop getSnapshotBeforeUpdate(prevProps, prevState)： 在组件更新之前获取快照 得组件能在发生更改之前从 DOM中捕获一些信息（如滚动位置） 返回值将作为参数传递给 componentDidUpdate() static getDerivedStateFromProps(props,state)&amp;#123; console.log('getDerivedStateFromProps',props,state); return null &amp;#125; getSnapshotBeforeUpdate()&amp;#123; console.log('getSnapshotBeforeUpdate'); return 'atguigu' &amp;#125; componentDidUpdate(preProps,preState,snapshotValue)&amp;#123; console.log('componentDidUpdate',preProps,preState,snapshotValue); &amp;#125; 最重要的三个钩子 render ：初始化渲染和更新渲染 componentDidMount ：进行初始化，如开启定时器、发送网络请求、订阅消息 componentWillUnmount ：进行收尾，如关闭定时器、取消订阅消息 虚拟 DOM 与 Diff 算法 key的作用key 是虚拟 DOM 对象的标识，可提高页面更新渲染的效率。 当状态中的数据发生变化时，React 会根据新数据生成新的虚拟 DOM ，接着对新旧虚拟 DOM 进行 Diff 比较，规则如下： 旧虚拟 DOM 找到和新虚拟 DOM 相同的 key： 若内容没变，直接复用真实 DOM 若内容改变，则生成新的真实 DOM ，替换页面中之前的真实 DOM 旧虚拟 DOM 未找到和新虚拟 DOM 相同的 key：根据数据创建新的真实 DOM ，渲染到页面 使用 index 作为 key 可能引发的问题： 若对数据进行逆序添加、逆序删除等破坏顺序的操作，会进行没有必要的真实 DOM 更新。界面效果没问题，但效率低下。 如果结构中包含输入类的 DOM（如 input 输入框） ，则会产生错误的 DOM 更新。 若不存在对数据逆序添加、逆序删除等破坏顺序的操作，则没有问题。","categories":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"黑马头条项目","slug":"黑马头条项目","permalink":"http://engravesunny.github.io/categories/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE/"},{"name":"Vue","slug":"Vue","permalink":"http://engravesunny.github.io/categories/Vue/"},{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/categories/React/"},{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"},{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"项目总结","slug":"项目总结","permalink":"http://engravesunny.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","permalink":"http://engravesunny.github.io/tags/vue/"},{"name":"后端的大数字","slug":"后端的大数字","permalink":"http://engravesunny.github.io/tags/%E5%90%8E%E7%AB%AF%E7%9A%84%E5%A4%A7%E6%95%B0%E5%AD%97/"},{"name":"search","slug":"search","permalink":"http://engravesunny.github.io/tags/search/"},{"name":"day.js","slug":"day-js","permalink":"http://engravesunny.github.io/tags/day-js/"},{"name":"第三方图片","slug":"第三方图片","permalink":"http://engravesunny.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%9B%BE%E7%89%87/"},{"name":"token","slug":"token","permalink":"http://engravesunny.github.io/tags/token/"},{"name":"postcssrc插件","slug":"postcssrc插件","permalink":"http://engravesunny.github.io/tags/postcssrc%E6%8F%92%E4%BB%B6/"},{"name":"笔记","slug":"笔记","permalink":"http://engravesunny.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Vue","slug":"Vue","permalink":"http://engravesunny.github.io/tags/Vue/"},{"name":"React","slug":"React","permalink":"http://engravesunny.github.io/tags/React/"},{"name":"博客修改","slug":"博客修改","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9/"},{"name":"博客","slug":"博客","permalink":"http://engravesunny.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}